{{/* Interactive Split Barriers â€” drag BEGIN marker to see GPU overlap */}}
<div class="interactive-widget" id="split-widget">
  <div class="widget-header">
    <span class="widget-icon">ðŸ”¬</span>
    <span class="widget-title">Interactive: Split Barriers</span>
    <p class="widget-hint">A barrier transitions a resource between states (e.g. render target â†’ shader read). A <strong>regular</strong> barrier stalls the GPU at the transition point. A <strong>split</strong> barrier spreads it over a gap â€” the GPU overlaps other work in between. Drag the <span style="color:var(--ds-danger);font-weight:700">BEGIN</span> marker left to widen the gap. Click any pass to reassign <span style="color:var(--ds-danger);font-weight:700">producer</span> / <span style="color:var(--ds-info);font-weight:700">consumer</span>.</p>
  </div>
  <div class="split-example-bar">
    <button class="split-ex-btn split-ex-active" onclick="splitSetExample(0)">SSAO â†’ Lighting</button>
    <button class="split-ex-btn" onclick="splitSetExample(1)">Shadow â†’ Forward</button>
    <button class="split-ex-btn" onclick="splitSetExample(2)">Bloom â†’ Composite</button>
  </div>
  <div class="widget-body">
    <svg id="split-svg" viewBox="0 0 680 310" style="width:100%;border-radius:.375rem;border:1px solid var(--color-neutral-200,#e5e5e5)"></svg>
    <div class="split-stats" id="split-stats"></div>
    <div class="split-explain" id="split-explain"></div>
    <div class="widget-btn-row">
      <button class="widget-btn" onclick="splitReset()">Reset</button>
    </div>
  </div>
</div>

<style>
:is(.dark,.scheme-congo) #split-svg{border-color:var(--color-neutral-700)}
.split-stats{display:flex;gap:.6em;flex-wrap:wrap;margin-top:.5em;font-family:ui-monospace,monospace;font-size:.8em}
.split-stat{padding:.3em .6em;border-radius:.25em;font-weight:600}
.split-stat-bad{background:var(--ds-danger);color:#fff}
.split-stat-ok{background:var(--ds-warn);color:#fff}
.split-stat-good{background:var(--ds-success);color:#fff}
.split-stat-neutral{background:var(--color-neutral-200,#e5e5e5);color:var(--color-neutral-700)}
:is(.dark,.scheme-congo) .split-stat-neutral{background:var(--color-neutral-700);color:var(--color-neutral-300)}
.split-explain{font-size:.84em;line-height:1.65;margin:.5em 0;padding:.5em .8em;border-radius:.375rem;border-left:3px solid var(--ds-info);background:var(--color-neutral-100,#f5f5f5);min-height:2em}
:is(.dark,.scheme-congo) .split-explain{background:var(--color-neutral-900);border-color:var(--ds-info)}
.split-example-bar{display:flex;gap:.5em;flex-wrap:wrap;margin-bottom:.5em}
.split-ex-btn{padding:.35em .9em;border-radius:999px;border:1.5px solid var(--color-neutral-300,#d1d5db);background:var(--color-neutral-100,#f5f5f5);font-size:.82em;font-weight:600;cursor:pointer;color:var(--color-neutral-700,#374151);transition:all .15s}
.split-ex-btn:hover{border-color:var(--ds-info);color:var(--ds-info)}
.split-ex-active{background:var(--ds-info)!important;color:#fff!important;border-color:var(--ds-info)!important;box-shadow:0 0 0 2px rgba(var(--ds-info-rgb),.25)!important}
:is(.dark,.scheme-congo) .split-ex-btn{border-color:var(--color-neutral-600);color:var(--color-neutral-300);background:var(--color-neutral-700)}
@keyframes splitCharge{to{stroke-dashoffset:-35}}
</style>

<script>
(function(){
var NS="http://www.w3.org/2000/svg";
var svg=document.getElementById("split-svg");

var EXAMPLES=[
  {
    name:"SSAO â†’ Lighting",
    passes:[
      {name:"Depth",dur:1.2,color:"#6b7280"},
      {name:"GBuffer",dur:2.0,color:"var(--ds-info)"},
      {name:"SSAO",dur:1.5,color:"var(--ds-code)"},
      {name:"Shadows",dur:2.2,color:"#64748b"},
      {name:"Lighting",dur:2.5,color:"var(--ds-warn)"},
      {name:"Tonemap",dur:0.8,color:"var(--ds-success)"}
    ],
    srcPass:2,dstPass:4,
    srcName:"SSAO",dstName:"Lighting",
    transLabel:"SSAO result â€” ColorAttachment â†’ ShaderRead"
  },
  {
    name:"Shadow â†’ Forward",
    passes:[
      {name:"Shadow CSM0",dur:1.0,color:"#64748b"},
      {name:"Shadow CSM1",dur:1.2,color:"#475569"},
      {name:"Shadow CSM2",dur:0.8,color:"#334155"},
      {name:"Depth",dur:1.5,color:"#6b7280"},
      {name:"Sky",dur:0.6,color:"#38bdf8"},
      {name:"Forward",dur:3.0,color:"var(--ds-warn)"},
      {name:"Post",dur:1.0,color:"var(--ds-success)"}
    ],
    srcPass:2,dstPass:5,
    srcName:"Shadow CSM2",dstName:"Forward",
    transLabel:"Shadow atlas â€” DepthWrite â†’ ShaderRead"
  },
  {
    name:"Bloom â†’ Composite",
    passes:[
      {name:"GBuffer",dur:2.5,color:"var(--ds-info)"},
      {name:"Lighting",dur:2.0,color:"var(--ds-warn)"},
      {name:"Bloom Down",dur:1.0,color:"#a855f7"},
      {name:"DOF",dur:1.5,color:"var(--ds-pink)"},
      {name:"TAA",dur:0.8,color:"var(--ds-teal)"},
      {name:"Composite",dur:0.6,color:"var(--ds-success)"}
    ],
    srcPass:2,dstPass:5,
    srcName:"Bloom Down",dstName:"Composite",
    transLabel:"Bloom mip chain â€” UAV Write â†’ ShaderRead"
  }
];

var curExIdx=0;
var passes,srcPass,dstPass,srcName,dstName,transLabel;

function loadExample(idx){
  curExIdx=idx;
  var ex=EXAMPLES[idx];
  passes=ex.passes.map(function(p){return{name:p.name,dur:p.dur,color:p.color}});
  srcPass=ex.srcPass;dstPass=ex.dstPass;
  srcName=ex.srcName;dstName=ex.dstName;
  transLabel=ex.transLabel;
  splitPos=1.0;
  document.querySelectorAll(".split-ex-btn").forEach(function(b,i){
    b.classList.toggle("split-ex-active",i===idx);
  });
  render();
}
window.splitSetExample=function(i){loadExample(i);}

var splitPos=1.0; // 1.0 = regular (begin at boundary), 0.0 = max split (begin right after src)
var dragging=false;
var srcEnd=0, dstStart=0; // boundaries for drag, updated by render()

function isDark(){
  return document.documentElement.classList.contains("dark")||
         document.documentElement.classList.contains("scheme-congo");
}

function el(tag,attrs,text){
  var e=document.createElementNS(NS,tag);
  if(attrs){for(var k in attrs)e.setAttribute(k,attrs[k]);}
  if(text!==undefined)e.textContent=text;return e;
}

function txt(x,y,text,fill,font,anchor){
  var t=el("text",{x:x,y:y,fill:fill,"text-anchor":anchor||"start"});
  t.style.font=font;t.textContent=text;return t;
}

function render(){
  while(svg.firstChild)svg.removeChild(svg.firstChild);
  var dk=isDark();
  var bg=dk?"#1a1a2e":"#f8fafc";
  var textC=dk?"#e5e5e5":"#1e293b";
  var gridC=dk?"#333":"#e2e8f0";
  var mutedC=dk?"#888":"#94a3b8";

  svg.append(el("rect",{x:0,y:0,width:680,height:310,fill:bg,rx:8}));

  var left=70,right=640,timeY=42,laneH=44;
  var totalDur=0;passes.forEach(function(p){totalDur+=p.dur;});
  var scale=(right-left)/totalDur;

  // Defs for arrow markers
  var defs=el("defs",{});
  defs.innerHTML='<marker id="split-al" viewBox="0 0 10 10" refX="2" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M10,0 L0,5 L10,10 z" fill="var(--ds-success)"/></marker>'+
    '<marker id="split-ar" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto"><path d="M0,0 L10,5 L0,10 z" fill="var(--ds-success)"/></marker>';
  svg.prepend(defs);

  // === ROW 1: Regular barrier ===
  var regY=timeY;
  svg.append(txt(12,regY+laneH/2+4,"Regular",mutedC,"bold 11px system-ui,sans-serif","start"));
  var t1=0;
  passes.forEach(function(p,i){
    var x=left+t1*scale+1;
    var w=p.dur*scale-2;
    svg.append(el("rect",{x:x,y:regY,width:w,height:laneH,rx:5,fill:p.color,opacity:.85}));
    if(i===srcPass) svg.append(el("rect",{x:x-1,y:regY-1,width:w+2,height:laneH+2,rx:6,fill:"none",stroke:"var(--ds-danger)","stroke-width":2}));
    if(i===dstPass) svg.append(el("rect",{x:x-1,y:regY-1,width:w+2,height:laneH+2,rx:6,fill:"none",stroke:"var(--ds-info)","stroke-width":2}));
    svg.append(txt(x+w/2,regY+laneH/2+4,p.name,"#fff","bold 11px ui-monospace,monospace","middle"));
    svg.append(txt(x+w/2,regY+laneH+12,p.dur.toFixed(1)+"ms",mutedC,"10px ui-monospace,monospace","middle"));
    t1+=p.dur;
  });

  // Full stall barrier between SSAO and Shadows (regular = at boundary)
  var regBarrierX=left;
  for(var bi=0;bi<=srcPass;bi++)regBarrierX+=passes[bi].dur*scale;
  // Stall indicator
  var stallW=12;
  svg.append(el("rect",{x:regBarrierX-stallW/2,y:regY-2,width:stallW,height:laneH+4,fill:"var(--ds-danger)",opacity:.25,rx:3}));
  svg.append(el("line",{x1:regBarrierX,y1:regY-5,x2:regBarrierX,y2:regY+laneH+5,stroke:"var(--ds-danger)","stroke-width":3}));
  svg.append(txt(regBarrierX,regY-8,"STALL",dk?"#f87171":"var(--ds-danger)","bold 9px ui-monospace,monospace","middle"));

  // === ROW 2: Split barrier ===
  var splitY=regY+laneH+40;
  svg.append(txt(12,splitY+laneH/2+4,"Split",mutedC,"bold 11px system-ui,sans-serif","start"));

  // Compute pass positions
  var passXs=[];var tx=0;
  passes.forEach(function(p){passXs.push(left+tx*scale);tx+=p.dur;});

  // Draw passes (click to reassign src/dst)
  passes.forEach(function(p,i){
    var x=passXs[i]+1;
    var w=p.dur*scale-2;
    svg.append(el("rect",{x:x,y:splitY,width:w,height:laneH,rx:5,fill:p.color,opacity:.85}));
    if(i===srcPass){
      svg.append(el("rect",{x:x-1,y:splitY-1,width:w+2,height:laneH+2,rx:6,fill:"none",stroke:"var(--ds-danger)","stroke-width":2.5}));
      svg.append(txt(x+w/2,splitY-6,"SRC","var(--ds-danger)","bold 9px ui-monospace,monospace","middle"));
    }
    if(i===dstPass){
      svg.append(el("rect",{x:x-1,y:splitY-1,width:w+2,height:laneH+2,rx:6,fill:"none",stroke:"var(--ds-info)","stroke-width":2.5}));
      svg.append(txt(x+w/2,splitY-6,"DST","var(--ds-info)","bold 9px ui-monospace,monospace","middle"));
    }
    svg.append(txt(x+w/2,splitY+laneH/2+4,p.name,"#fff","bold 11px ui-monospace,monospace","middle"));
    var hit=el("rect",{x:x,y:splitY-2,width:w,height:laneH+4,fill:"transparent",style:"cursor:pointer",rx:5});
    (function(idx){hit.addEventListener("click",function(ev){ev.stopPropagation();handlePassClick(idx);});})(i);
    svg.append(hit);
  });

  // Split barrier: BEGIN can slide from right after srcPass ends to just before dstPass starts
  srcEnd=passXs[srcPass]+passes[srcPass].dur*scale;
  dstStart=passXs[dstPass];
  var gapWidth=dstStart-srcEnd;
  // splitPos: 1.0 = begin at dstStart (=regular), 0.0 = begin at srcEnd (max split)
  var beginX=srcEnd+(dstStart-srcEnd)*splitPos;
  var endX=dstStart;

  // Overlap shading
  if(splitPos<0.95){
    svg.append(el("rect",{x:beginX,y:splitY-2,width:endX-beginX,height:laneH+4,fill:"var(--ds-success)",opacity:.12,rx:4}));
    // Overlap arrow
    if(endX-beginX>30){
      svg.append(el("line",{x1:beginX+8,y1:splitY+laneH+14,x2:endX-8,y2:splitY+laneH+14,stroke:"var(--ds-success)","stroke-width":2,"marker-start":"url(#split-al)","marker-end":"url(#split-ar)"}));
      // Flowing charge overlay for overlap arrow
      var oFlow=el("line",{x1:beginX+8,y1:splitY+laneH+14,x2:endX-8,y2:splitY+laneH+14,stroke:"#4ade80","stroke-width":"3","stroke-dasharray":"10 25","stroke-linecap":"round","pointer-events":"none",opacity:".55",style:"animation:splitCharge 1.8s linear infinite"});
      svg.append(oFlow);
      svg.append(txt((beginX+endX)/2,splitY+laneH+28,"GPU overlaps here","var(--ds-success)","bold 10px ui-monospace,monospace","middle"));
    }
  }

  // BEGIN marker (draggable)
  svg.append(el("line",{x1:beginX,y1:splitY-8,x2:beginX,y2:splitY+laneH+10,stroke:"var(--ds-danger)","stroke-width":2.5,"stroke-dasharray":"4,2"}));
  svg.append(el("rect",{x:beginX-24,y:splitY+laneH+35,width:48,height:18,rx:4,fill:"var(--ds-danger)"}));
  svg.append(txt(beginX,splitY+laneH+48,"BEGIN","#fff","bold 9px ui-monospace,monospace","middle"));

  // END marker (fixed at destination start)
  svg.append(el("line",{x1:endX,y1:splitY-8,x2:endX,y2:splitY+laneH+10,stroke:"var(--ds-info)","stroke-width":2.5,"stroke-dasharray":"4,2"}));
  svg.append(el("rect",{x:endX-20,y:splitY+laneH+35,width:40,height:18,rx:4,fill:"var(--ds-info)"}));
  svg.append(txt(endX,splitY+laneH+48,"END","#fff","bold 9px ui-monospace,monospace","middle"));

  // Drag hit area
  var dragHit=el("rect",{x:beginX-18,y:splitY-10,width:36,height:laneH+25,fill:"transparent",style:"cursor:ew-resize"});
  svg.append(dragHit);

  // Transition label
  var transY=splitY+laneH+70;
  svg.append(txt(left+(right-left)/2,transY,"Transition: "+transLabel,mutedC,"11px ui-monospace,monospace","middle"));

  // === ROW 3: Timeline comparison ===
  var cmpY=transY+20;
  // Regular total time (has stall)
  var stallMs=0.3; // assumed stall cost
  var regTotal=totalDur+stallMs;
  var splitTotal=totalDur; // no stall when fully split
  var overlapPct=Math.round((1-splitPos)*100);

  var pctSaved=overlapPct>5?((stallMs/regTotal)*100*(overlapPct/100)):0;

  // API callout
  var apiY=cmpY+18;
  svg.append(txt(left,apiY,"Vulkan: vkCmdSetEvent2 (begin) / vkCmdWaitEvents2 (end)",mutedC,"10px ui-monospace,monospace","start"));
  svg.append(txt(left,apiY+14,"D3D12:  BARRIER_FLAG_BEGIN_ONLY / BARRIER_FLAG_END_ONLY",mutedC,"10px ui-monospace,monospace","start"));

  updateInfo();
}

// Drag logic â€” attached once outside render(), gated by rAF
var dragRafPending = false;
function onDragMove(clientX) {
  if (!dragging) return;
  var rect = svg.getBoundingClientRect();
  var svgX = (clientX - rect.left) / rect.width * 680;
  var ratio = (svgX - srcEnd) / (dstStart - srcEnd);
  splitPos = Math.max(0, Math.min(1, ratio));
  if (!dragRafPending) {
    dragRafPending = true;
    requestAnimationFrame(function() { dragRafPending = false; render(); });
  }
}
svg.addEventListener("mousedown", function(ev) {
  var rect = svg.getBoundingClientRect();
  var svgX = (ev.clientX - rect.left) / rect.width * 680;
  var beginX = srcEnd + (dstStart - srcEnd) * splitPos;
  if (Math.abs(svgX - beginX) < 24) { dragging = true; ev.preventDefault(); }
});
svg.addEventListener("mousemove", function(ev) { onDragMove(ev.clientX); });
svg.addEventListener("mouseup", function() { dragging = false; });
svg.addEventListener("mouseleave", function() { dragging = false; });
svg.addEventListener("touchstart", function(ev) {
  var rect = svg.getBoundingClientRect();
  var svgX = (ev.touches[0].clientX - rect.left) / rect.width * 680;
  var beginX = srcEnd + (dstStart - srcEnd) * splitPos;
  if (Math.abs(svgX - beginX) < 24) { dragging = true; ev.preventDefault(); }
}, {passive: false});
svg.addEventListener("touchmove", function(ev) {
  onDragMove(ev.touches[0].clientX);
}, {passive: false});
svg.addEventListener("touchend", function() { dragging = false; });

function handlePassClick(idx){
  if(idx===srcPass||idx===dstPass)return;
  if(idx<srcPass){
    if(dstPass-idx>=2) srcPass=idx;
  }else if(idx>dstPass){
    if(idx-srcPass>=2) dstPass=idx;
  }else{
    if(idx-srcPass<=dstPass-idx){
      if(dstPass-idx>=2) srcPass=idx;
    }else{
      if(idx-srcPass>=2) dstPass=idx;
    }
  }
  srcName=passes[srcPass].name;
  dstName=passes[dstPass].name;
  transLabel=srcName+" output \u2192 "+dstName+" input";
  splitPos=1.0;
  render();
}

function updateInfo(){
  var overlapPct=Math.round((1-splitPos)*100);
  var statsEl=document.getElementById("split-stats");
  var explainEl=document.getElementById("split-explain");

  // Stats badges
  var badges="";
  if(overlapPct<5){
    badges='<span class="split-stat split-stat-bad">Regular barrier â€” full GPU stall</span>';
  }else if(overlapPct<50){
    badges='<span class="split-stat split-stat-ok">Split: '+overlapPct+'% overlap</span>';
  }else{
    badges='<span class="split-stat split-stat-good">Split: '+overlapPct+'% overlap</span>';
  }
  // Count gap passes
  var gapPasses=0;
  for(var i=srcPass+1;i<dstPass;i++)gapPasses++;
  badges+=' <span class="split-stat split-stat-neutral">Gap: '+gapPasses+' pass'+(gapPasses!==1?"es":"")+'</span>';
  statsEl.innerHTML=badges;

  // Explanation
  if(overlapPct<5){
    explainEl.innerHTML=
      "<strong>Regular barrier:</strong> The GPU finishes "+srcName+", <em>stalls</em> while it flushes caches, then starts the next pass. The stall wastes GPU cycles. "+
      "<strong>Drag the red BEGIN marker left</strong> to split the barrier and see how the GPU can overlap the cache flush with other work.";
  }else{
    explainEl.innerHTML=
      "<strong>Split barrier ("+overlapPct+"% overlap):</strong> BEGIN (flush) fires right after "+srcName+" completes â€” the GPU starts flushing caches. "+
      "Meanwhile, the "+gapPasses+" pass"+(gapPasses!==1?"es":"")+" in the gap run"+(gapPasses===1?"s":"")+" â€” they don't touch the transitioning resource, so there's no conflict. "+
      "END (invalidate) fires just before "+dstName+", ensuring caches are ready. "+
      "<br><br><strong>Result:</strong> The GPU never stalls â€” the transition cost is fully hidden."+
      (overlapPct>80?" <strong style='color:var(--ds-success)'>Maximum overlap achieved.</strong>":"");
  }
}

window.splitReset=function(){
  splitPos=1.0;
  render();
};

loadExample(0);
var obs=new MutationObserver(function(){render();});
obs.observe(document.documentElement,{attributes:true,attributeFilter:["class"]});
})();
</script>
